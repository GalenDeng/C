// 自带的strcpy库函数的缺陷；使用strcpy函数之前记得给原字符串和目标字符串留足够的空间
// 因为s[],d[]的内存空间是在栈上分配的,所以是分配的是连续的内存空间,且栈的分配的地址是从高地址到低地址的
#include <iostream>
#include <stdio.h>

int main(void)
{
// 在栈上分配数组s的内存空间,存入 ('1','2','3','4','5','6','7','8','9','\0') [低地址是'1',高地址是'\0']
	char s[] = "123456789";	
// 在栈上分配数组d的内存空间,注意数组d分配到的内存空间的地址小于数组s分配到的内存空间地址
// 存入 ('1','2','3','\0') [低地址是'1',高地址是'\0']
// 且栈上分配的内存是连续的,且两个变量的内存空间是紧挨着,所以我们必须保证前一个变量不会访问到后一变量的内存空间地址
	char d[] = "123";
//							  d        s
//内存空间地址从小到大排列为: 1 2 3 \0 1 2 3 4 5 6  7 8 9 \0
// 库函数strcpy执行后:        1 2 3 4  5 6 7 8 9 \0 7 8 9 \0
//printf打印是从开始打印,遇到 '\0'即停止, 所以 printf出的 d = "123456789"  s = "56789"
	strcpy(d,s);
	printf("%s\n%s\n", d,s);
	return 0;
}

/*
 * VC6.0调试结果:
123456789
56789
Press any key to continue
*/

// 若改成这样
#include <iostream>
#include <stdio.h>

int main(void)
{
//	char s[] = "123456789";	// 栈分配的地址的方向是 从高地址到低地址
//	char d[] = "123";

	char d[] = "123";
	char s[] = "123456789";	// 栈分配的地址的方向是 从高地址到低地址
	strcpy(d,s);
	printf("%s\n%s\n", d,s);
	return 0;
}
// 虽然看到正确的输出结果,但是复制的时候已经超过了分配给数组d的内存空间了,会导致运行时错误