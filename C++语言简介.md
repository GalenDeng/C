## C++语言简介 (2017.11.27)

1. `c++语言特点`
```
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面
向对象编程和泛型编程。
C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点
```
2. `面向对象的四大特征`
```
* 封装 抽象 继承 多态
```
3. `STL`
```
* 标准模板库 Standard template library
```
4. `注释`
```
块注释符（/*...*/）是不可以嵌套使用的
```
```
此外，我们还可以使用 #if 0 ... #endif 来实现注释，且可以实现嵌套，格式为：
#if 0
   code
#endif 
```
5. `<iostream>的问题`
```
现在大家买的C++教材可能会经常看到头文件是如下:
#include <iostream>
然后用现在较新的软件则会提示：无法打开源文件"iostream.h"。
这是因为现在新的软件都是采用标准 C 格式，而 iostream.h 是 VC6.0 使用的风格，也就是标准 C 格式还未出台之前的风格。
出现上述提示只需要进行如下修改:
#include <iostream>
using namespace std;
```
6. `左值（Lvalues）和右值（Rvalues）`
```
* 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
* 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
* 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边
```
7. `自动转换`
* 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
* 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。
*   a、若两种类型的字节数不同，转换成字节数高的类型
*   b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
* `所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算`
* char型和short型参与运算时，必须先转换成int型。
* `在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型`。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:
8. `强制转换规则`
```
强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式）其功能是把表达式的运算结果强制转换成类型说明符所表示的类型
```
* example
```
int a = 1;
double b = 2.1;
cout << "a + b = " << a + (int)b << endl;  //输出为a + b = 3
```
9. `定义包含了声明，但是声明不包含定义`
```
int a = 0;     //定义并声明了变量 a
extern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找
```
10. `初始化局部变量和全局变量`
```
当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：
```
* ![全局变量的初始化](https://github.com/GalenDeng/C/blob/master/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E5%8C%96.png)
11. `整型常量`
```
整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意
```
```
212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
```
12. `布尔常量`
```
布尔常量共有两个，它们都是标准的 C++ 关键字：
true 值代表真。
false 值代表假。
我们不应把 true 的值看成 1，把 false 的值看成 0
```
13. `定义常量`
```
定义常量
在 C++ 中，有两种简单的定义常量的方式：
使用 #define 预处理器。
使用 const 关键字。
```
```
#define identifier value
```
```
   const int  LENGTH = 10;
```
* 定义成 const 后的常量，程序对其中只能读不能修改
* 以下为错误写法
```
#include <iostream>
using namespace std;
int main()
{
    const double pi;                      //圆周率的值用pi表示
    pi=3.14159265;
    cout<<"圆周率的近似值是"<<pi<<endl;
    return 0;
}
```
* 应把     const double pi;pi=3.14159265; 改为 const double pi=3.141592;

14. `宏定义 #define 和常量 const 的区别`
```
* 类型和安全检查不同
宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；
const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
* 编译器处理不同
宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；
const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据
* 存储方式不同
宏定义是直接替换，不会分配内存，存储与程序的代码段中；
const常量需要进行内存分配，存储与程序的数据段中
* 定义域不同
void f1 ()
{
    #define N 12
    const int n 12;
}
void f2 ()
{
    cout<<N <<endl; //正确，N已经定义过，不受定义域限制
    cout<<n <<endl; //错误，n定义域只在f1函数中
}
* 定义后能否取消
    宏定义可以通过#undef来使之前的宏定义失效
    const常量定义后将在定义域内永久有效
void f1()
{
  #define N 12
  const int n = 12;

  #undef N //取消宏定义后，即使在f1函数中，N也无效了
  #define N 21//取消后可以重新定义
}
* 是否可以做函数参数
  宏定义不能作为参数传递给函数
  const常量可以在函数的参数列表中出现
```
15. `const的注意事项`
```
* const 定义常量之后，是不能够改变的
* 宏定义是可以取消的
      定义： #define    N    21
      取消： #undef    N    12

* const限定符定以后是不可以改变的，所以在定义时必须赋初始值，要不然是错误的，除非这个变量是用extern修饰的外部变量。 例如：
const int A=10;       //正确。
const int A;          //错误，没有赋初始值。
extern const int A;   //正确，使用extern的外部变量。
```
16. `速记符号声明`
```
C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量
```
```
下面的两个语句都声明了无符号整型变量。
unsigned x;
unsigned int y;
```
17. `C++ 修饰符类型`
```
* C++ 允许在 char、int 和 double 数据类型前放置修饰符
* 数据类型修饰符：signed unsigned long short
* 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。
修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int
```